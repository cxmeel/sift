[{"title":"Sift","type":0,"sectionRef":"#","url":"/sift/api/Sift","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Sift","url":"/sift/api/Sift#types","content":" "},{"title":"None​","type":1,"pageTitle":"Sift","url":"/sift/api/Sift#None","content":"&lt;/&gt; type None = None  "},{"title":"Properties​","type":1,"pageTitle":"Sift","url":"/sift/api/Sift#properties","content":" "},{"title":"Array​","type":1,"pageTitle":"Sift","url":"/sift/api/Sift#Array","content":"&lt;/&gt; Sift.Array: Array   "},{"title":"List​","type":1,"pageTitle":"Sift","url":"/sift/api/Sift#List","content":"Alias &lt;/&gt; Sift.List: Array   "},{"title":"Dictionary​","type":1,"pageTitle":"Sift","url":"/sift/api/Sift#Dictionary","content":"&lt;/&gt; Sift.Dictionary: Dictionary   "},{"title":"Set​","type":1,"pageTitle":"Sift","url":"/sift/api/Sift#Set","content":"&lt;/&gt; Sift.Set: Set   "},{"title":"Types​","type":1,"pageTitle":"Sift","url":"/sift/api/Sift#Types","content":"&lt;/&gt; Sift.Types: Types   "},{"title":"None​","type":1,"pageTitle":"Sift","url":"/sift/api/Sift#None","content":"&lt;/&gt; Sift.None: None Luau can't distinguish between a nil value and a non-existent value. This constant is used to represent a non-existent value. It can be used in methods like Array.Concat or Dictionary.Merge to remove the value from the result. "},{"title":"Functions​","type":1,"pageTitle":"Sift","url":"/sift/api/Sift#functions","content":" "},{"title":"isEmpty​","type":1,"pageTitle":"Sift","url":"/sift/api/Sift#isEmpty","content":"since v0.0.1 &lt;/&gt; Sift.isEmpty( table: table-- The table to check. ) → boolean-- Whether or not the table is empty. Checks whether or not a table is empty. local a = {} local b = { hello = &quot;world&quot; } local value = isEmpty(a) -- true local value = isEmpty(b) -- false   "},{"title":"equalObjects​","type":1,"pageTitle":"Sift","url":"/sift/api/Sift#equalObjects","content":"&lt;/&gt; Sift.equalObjects( ...: ...table-- The tables to compare. ) → boolean-- Whether or not the tables are equal. Compares two or more tables to see if they are equal. local a = { hello = &quot;world&quot; } local b = { hello = &quot;world&quot; } local equal = EqualObjects(a, b) -- true  "},{"title":"Examples","type":0,"sectionRef":"#","url":"/sift/docs/Examples","content":"","keywords":""},{"title":"Combining Data​","type":1,"pageTitle":"Examples","url":"/sift/docs/Examples#combining-data","content":"local dictionary1 = { a = 1, b = 2 } local dictionary2 = { c = 3, d = 4 } local result = Sift.Dictionary.merge(dictionary1, dictionary2) -- { a = 1, b = 2, c = 3, d = 4 }  local array1 = { 1, 2, 3 } local array2 = { 4, 5, 6 } local result = Sift.Array.concat(array1, array2) -- { 1, 2, 3, 4, 5, 6 }  "},{"title":"Filtering Data​","type":1,"pageTitle":"Examples","url":"/sift/docs/Examples#filtering-data","content":"The following example filters out all uneven numbers from an array of numbers. local array = { 1, 2, 3, 4, 5, 6 } local result = Sift.Array.filter(array, function(value) return value % 2 == 0 end) -- { 2, 4, 6 }  Dictionaries can also be filtered in Sift! local dictionary = { a = 1, b = 2, c = 3, d = 4 } local result = Sift.Dictionary.filter(dictionary, function(value) return value % 2 == 0 end) -- { b = 2, d = 4 }  "},{"title":"Removing Duplicates​","type":1,"pageTitle":"Examples","url":"/sift/docs/Examples#removing-duplicates","content":"There's a few different methods for removing duplicates from an array or dictionary. The following example removes all duplicate values from an array using sets. local array = { &quot;hello&quot;, &quot;world&quot;, &quot;world&quot;, &quot;cat&quot;, &quot;dog&quot; } local set = Sift.Set.fromArray(array) -- { &quot;hello&quot; = true, &quot;world&quot; = true, &quot;cat&quot; = true, &quot;dog&quot; = true } local result = Sift.Set.toArray(set) -- { &quot;hello&quot;, &quot;world&quot;, &quot;cat&quot;, &quot;dog&quot; }  The same could also be accomplished using a reducer. local array = { &quot;hello&quot;, &quot;world&quot;, &quot;world&quot;, &quot;cat&quot;, &quot;dog&quot; } local result = Sift.Array.reduce(array, function(accumulator, value) if not Sift.Array.includes(accumulator, value) then return Sift.Array.push(accumulator, value) end return accumulator end, {}) -- { &quot;hello&quot;, &quot;world&quot;, &quot;cat&quot;, &quot;dog&quot; }  "},{"title":"Installation","type":0,"sectionRef":"#","url":"/sift/docs/Installation","content":"","keywords":""},{"title":"Wally​","type":1,"pageTitle":"Installation","url":"/sift/docs/Installation#wally","content":"Wally is a CLI package manager (much like NPM, Yarn or Cargo) for Roblox by @UpliftGames. Find out more at https://github.com/upliftgames/wally. # wally.toml [dependencies] Sift = &quot;csqrl/sift@=0.0.1&quot;  $ wally install  "},{"title":"TypeScript​","type":1,"pageTitle":"Installation","url":"/sift/docs/Installation#typescript","content":"v0.0.1 of Sift includes TypeScript definitions. This means Sift is now compatible with roblox-ts. Refer to the Luau docs for API details. $ npm install @rbxts/sift  View on NPM → // example.ts import Sift from &quot;@rbxts/sift&quot; Sift.Dictionary.merge({ a: 1, c: 2 }, { b: 3, c: Sift.None }) // { a: 1, b: 3 }  Alternatively, you can use tree-shaking to access the modules directly. // example.ts import { Dictionary, None } from &quot;@rbxts/sift&quot; Dictionary.merge({ a: 1, c: 2 }, { b: 3, c: None }) // { a: 1, b: 3 }  "},{"title":"Manual Installation​","type":1,"pageTitle":"Installation","url":"/sift/docs/Installation#manual-installation","content":"Grab a copy from the Roblox Library or GitHub releases, and drop it into Studio. The Sift model file can be synced in using Rojo. "},{"title":"Set","type":0,"sectionRef":"#","url":"/sift/api/Set","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Set","url":"/sift/api/Set#functions","content":" "},{"title":"copy​","type":1,"pageTitle":"Set","url":"/sift/api/Set#copy","content":"&lt;/&gt; Set.copy( set: {[T]: boolean}-- The set to copy. ) → {[T]: boolean}-- A copy of the set. Creates a copy of a set. local set = { hello = true } local newSet = Copy(set) -- { hello = true }   "},{"title":"fromArray​","type":1,"pageTitle":"Set","url":"/sift/api/Set#fromArray","content":"&lt;/&gt; Set.fromArray( array: {T}-- The array to convert to a set. ) → {[T]: boolean}-- The set. Converts an array to a set, where each item is mapped to true. Duplicate items are discarded. Aliases: fromList local array = { &quot;hello&quot;, &quot;world&quot;, &quot;hello&quot; } local set = FromArray(array) -- { hello = true, world = true }   "},{"title":"map​","type":1,"pageTitle":"Set","url":"/sift/api/Set#map","content":"&lt;/&gt; Set.map( set: {[T]: boolean},-- The set to map. mapper: ( T, {[T]: boolean} ) → U-- The mapper function. ) → {[U]: boolean}-- The mapped set. Iterates over a set, calling a mapper function for each item. local set = { hello = true, world = true } local mappedSet = Map(set, function(value) return value .. &quot;!&quot; end) -- { [&quot;hello!&quot;] = true, [&quot;world!&quot;] = true }   "},{"title":"intersection​","type":1,"pageTitle":"Set","url":"/sift/api/Set#intersection","content":"&lt;/&gt; Set.intersection( ...: ...{[any]: boolean}-- The sets to intersect. ) → {[T]: boolean}-- The intersection of the sets. Creates the intersection of multiple sets. The intersection is when both sets have a value in common. Unmatched values are discarded. local set1 = { hello = true, world = true } local set2 = { world = true, universe = true } local intersection = Intersection(set1, set2) -- { world = true }   "},{"title":"difference​","type":1,"pageTitle":"Set","url":"/sift/api/Set#difference","content":"&lt;/&gt; Set.difference( set: Set&lt;V&gt;,-- The set to compare. ...: ...Set&lt;V&gt;-- The sets to compare against. ) → Set&lt;V&gt;-- The difference between the sets. Returns a set of values that are in the first set, but not in the other sets. local set1 = { hello = true, world = true } local set2 = { cat = true, dog = true, hello = true } local difference = Difference(set1, set2) -- { world = true }   "},{"title":"isSuperset​","type":1,"pageTitle":"Set","url":"/sift/api/Set#isSuperset","content":"&lt;/&gt; Set.isSuperset( superset: {[any]: boolean},-- The superset to check. subset: {[any]: boolean}-- The subset to check against. ) → boolean-- Whether the superset is a superset of the subset. Checks whether a set is a superset of another set. local set = { hello = true, world = true } local subset = { hello = true } local isSuperset = IsSuperset(set, subset) -- true   "},{"title":"merge​","type":1,"pageTitle":"Set","url":"/sift/api/Set#merge","content":"&lt;/&gt; Set.merge( ...: ...any-- The sets to merge. ) → {[T]: boolean}-- The merged set. Combines one or more sets into a single set. Aliases: join, union local set1 = { hello = true, world = true } local set2 = { cat = true, dog = true, hello = true } local merge = Merge(set1, set2) -- { hello = true, world = true, cat = true, dog = true }   "},{"title":"filter​","type":1,"pageTitle":"Set","url":"/sift/api/Set#filter","content":"&lt;/&gt; Set.filter( set: {[T]: boolean},-- The set to filter. predicate?: ( item: T, set: {[T]: boolean} ) → any-- The function to filter the set with. ) → {[T]: boolean}-- The filtered set. Filters a set using a predicate. Any items that do not pass the predicate will be removed from the set. local set = { hello = true, world = true } local newSet = Filter(set, function(value) return value ~= &quot;hello&quot; end) -- { world = true }   "},{"title":"isSubset​","type":1,"pageTitle":"Set","url":"/sift/api/Set#isSubset","content":"&lt;/&gt; Set.isSubset( subset: {[any]: boolean},-- The subset to check. superset: {[any]: boolean}-- The superset to check against. ) → boolean-- Whether the subset is a subset of the superset. Checks whether a set is a subset of another set. local set = { hello = true, world = true } local subset = { hello = true } local isSubset = IsSubset(subset, set) -- true   "},{"title":"count​","type":1,"pageTitle":"Set","url":"/sift/api/Set#count","content":"&lt;/&gt; Set.count( set: {[T]: boolean},-- The set to count. predicate?: ( item: T, set: {[T]: boolean} ) → boolean?-- The predicate to use to count. ) → number-- The number of items in the set. Counts the number of items in a set. local set = { hello = true, world = true } local count = Count(set) -- 2 local count = Count(set, function(item) return item == &quot;hello&quot; end) -- 1   "},{"title":"toArray​","type":1,"pageTitle":"Set","url":"/sift/api/Set#toArray","content":"&lt;/&gt; Set.toArray( set: {[T]: boolean}-- The set to convert to an array. ) → {T}-- The array. Converts a set to an array. local set = { hello = true, world = true } local array = ToArray(set) -- { &quot;hello&quot;, &quot;world&quot; }   "},{"title":"delete​","type":1,"pageTitle":"Set","url":"/sift/api/Set#delete","content":"&lt;/&gt; Set.delete( set: {[T]: boolean},-- The set to delete from. ...: ...T-- The values to delete. ) → {[T]: boolean}-- The set with the values deleted. Deletes values from a set. Aliases: subtract local set = { hello = true, world = true } local newSet = Delete(set, &quot;hello&quot;) -- { world = true }   "},{"title":"has​","type":1,"pageTitle":"Set","url":"/sift/api/Set#has","content":"&lt;/&gt; Set.has( set: {[T]: boolean},-- The set to check. value: any-- The value to check for. ) → boolean-- Whether the value is in the set. Checks whether a value is in a set. local set = { hello = true } local has = Has(set, &quot;hello&quot;) -- true   "},{"title":"add​","type":1,"pageTitle":"Set","url":"/sift/api/Set#add","content":"&lt;/&gt; Set.add( set: {[T]: boolean},-- The set to add the value to. ...: ...T-- The values to add. ) → {[T]: boolean}-- The set with the values added. Adds values to a set. local set = { hello = true } local newSet = Add(set, &quot;world&quot;) -- { hello = true, world = true }   "},{"title":"differenceSymmetric​","type":1,"pageTitle":"Set","url":"/sift/api/Set#differenceSymmetric","content":"&lt;/&gt; Set.differenceSymmetric( set: Set&lt;V&gt;,-- The set to compare. ...: ...Set&lt;V&gt;-- The sets to compare against. ) → Set&lt;V&gt;-- The symmetric difference between the sets. Returns a set of values that are in the first set, but not in the other sets, and vice versa. local set1 = { hello = true, world = true } local set2 = { cat = true, dog = true, hello = true } local differenceSymmetric = DifferenceSymmetric(set1, set2) -- { world = true, cat = true, dog = true }  "},{"title":"Sift","type":0,"sectionRef":"#","url":"/sift/docs/intro","content":"","keywords":""},{"title":"Get Started​","type":1,"pageTitle":"Sift","url":"/sift/docs/intro#get-started","content":"Installation guideAPI DocumentationExamples "},{"title":"Why Immutable?​","type":1,"pageTitle":"Sift","url":"/sift/docs/intro#why-immutable","content":"With immutable data structures, you're in control of your data. You can't accidentally change the data, and you can always predict what will happen to your data and the state of your data. This helps you to prevent bugs and unexpected behavior. Because immutable data structures cannot be changed, this allows for tracking of changes to your data. This is useful for debugging and testing. While Sift doesn't enforce immutability, it provides a way to work with data as if it were immutable. "},{"title":"Dictionary","type":0,"sectionRef":"#","url":"/sift/api/Dictionary","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#functions","content":" "},{"title":"copy​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#copy","content":"&lt;/&gt; Dictionary.copy( dictionary: T-- The dictionary to copy. ) → T-- The copied dictionary. Copies a dictionary. local dictionary = { hello = &quot;world&quot; } local new = Copy(dictionary) -- { hello = &quot;world&quot; } print(new == dictionary) -- false print(new.hello == dictionary.hello) -- true   "},{"title":"update​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#update","content":"&lt;/&gt; Dictionary.update( dictionary: {[K]: V?},-- The dictionary to update. key: K,-- The key to update. updater?: ( value: V, key: K ) → U,-- The updater function. callback?: (key: K) → C-- The callback function. ) → {[K]: V | U | C}-- The updated dictionary. Updates a value in a dictionary at the given key. If the value at the given key does not exist, callback will be called, and its return value will be used as the value at the given key. local dictionary = { cats = 2 } local new = Update(dictionary, &quot;cats&quot;, function(value) return value + 1 end) -- { cats = 3 } local new = Update(dictionary, &quot;dogs&quot;, function(value) return value + 1 end, function(value) return 1 end) -- { cats = 3, dogs = 1 }   "},{"title":"map​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#map","content":"&lt;/&gt; Dictionary.map( dictionary: {[K]: V},-- The dictionary to map. mapper: ( value: V, key: K, dictionary: {[K]: V} ) → ( Y?, X? )-- The mapper function. ) → {[X]: Y}-- The mapped dictionary. Maps the dictionary using the mapper function. The mapper function can return a value and a key. If the mapper function does not return a key, the original key will be used. local dictionary = { hello = 10, goodbye = 20 } local new = Map(dictionary, function(value, key) return value * 2, key .. &quot;!&quot; end) -- { [&quot;hello!&quot;] = 20, [&quot;goodbye!&quot;] = 40 } local new = Map(dictionary, function(value, key) return value * 10 end) -- { hello = 100, goodbye = 200 }   "},{"title":"flatten​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#flatten","content":"&lt;/&gt; Dictionary.flatten( dictionary: T,-- The dictionary to flatten. depth?: number-- The depth to flatten the dictionary to. ) → T-- The flattened dictionary. Flattens a dictionary. If depth is not specified, it will flatten the dictionary as far as it can go. local dictionary = { hello = &quot;world&quot;, goodbye = { world = &quot;hello&quot;, roblox = { yes = &quot;no&quot;, no = &quot;yes&quot;, } } } local new = Flatten(dictionary) -- { hello = &quot;world&quot;, world = &quot;hello&quot;, yes = &quot;no&quot;, no = &quot;yes&quot; } local new = Flatten(dictionary, 1) -- { hello = &quot;world&quot;, world = &quot;hello&quot;, roblox = { yes = &quot;no&quot;, no = &quot;yes&quot; } }   "},{"title":"includes​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#includes","content":"&lt;/&gt; Dictionary.includes( dictionary: {[K]: V},-- The dictionary to check. value: V-- The value to check for. ) → boolean-- Whether or not the dictionary includes the given value. Checks whether or not the given dictionary includes the given value. local dictionary = { hello = &quot;roblox&quot;, goodbye = &quot;world&quot; } local includesRoblox = Includes(dictionary, &quot;roblox&quot;) -- true local includesCat = Includes(dictionary, &quot;cat&quot;) -- false   "},{"title":"removeValues​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#removeValues","content":"&lt;/&gt; Dictionary.removeValues( dictionary: {[K]: V},-- The dictionary to remove the values from. values: ...V-- The values to remove. ) → {[K]: V}-- The dictionary without the given values. Removes the given values from the given dictionary. local dictionary = { hello = &quot;world&quot;, cat = &quot;meow&quot;, unicorn = &quot;rainbow&quot;, goodbye = &quot;world&quot; } local withoutWorld = RemoveValues(dictionary, &quot;world&quot;) -- { cat = &quot;meow&quot;, unicorn = &quot;rainbow&quot; } local onlyWorld = RemoveValues(dictionary, &quot;meow&quot;, &quot;rainbow&quot;) -- { hello = &quot;world&quot;, goodbye = &quot;world&quot; }   "},{"title":"mergeDeep​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#mergeDeep","content":"&lt;/&gt; Dictionary.mergeDeep( dictionaries?: ...any-- The dictionaries to merge. ) → T-- The merged dictionary. Merges the given dictionaries into a single dictionary. If the value is None, it will be removed from the result. This is recursive. The parameters may be any number of dictionaries or nil. Non-dictonaries will be ignored. Aliases: joinDeep local dictionary1 = { hello = &quot;roblox&quot;, goodbye = { world = &quot;goodbye&quot; } } local dictionary2 = { goodbye = { world = &quot;world&quot; } } local merged = MergeDeep(dictionary1, dictionary2) -- { hello = &quot;roblox&quot;, goodbye = { world = &quot;world&quot; } }   "},{"title":"removeValue​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#removeValue","content":"&lt;/&gt; Dictionary.removeValue( dictionary: {[K]: V},-- The dictionary to remove the value from. value: V-- The value to remove. ) → {[K]: V}-- The dictionary without the given value. Removes the given value from the given dictionary. local dictionary = { hello = &quot;roblox&quot;, goodbye = &quot;world&quot; } local withoutHello = RemoveValue(dictionary, &quot;roblox&quot;) -- { goodbye = &quot;world&quot; } local withoutGoodbye = RemoveValue(dictionary, &quot;world&quot;) -- { hello = &quot;roblox&quot; }   "},{"title":"merge​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#merge","content":"&lt;/&gt; Dictionary.merge( dictionaries?: ...any-- The dictionaries to merge. ) → T-- The merged dictionary. Merges the given dictionaries into a single dictionary. If the value is None, it will be removed from the result. The parameters may be any number of dictionaries or nil. Non-dictonaries will be ignored. Aliases: join local dictionary1 = { hello = &quot;roblox&quot;, goodbye = &quot;world&quot; } local dictionary2 = { goodbye = &quot;goodbye&quot; } local merged = Merge(dictionary1, dictionary2) -- { hello = &quot;roblox&quot;, goodbye = &quot;goodbye&quot; }   "},{"title":"filter​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#filter","content":"&lt;/&gt; Dictionary.filter( dictionary: {[K]: V},-- The dictionary to filter. predicate?: ( value: V, key: K, dictionary: {[K]: V} ) → any-- The predicate to use to filter the dictionary. ) → {[K]: V}-- The filtered dictionary. Filters a dictionary using a predicate. Any items that do not pass the predicate will be removed from the dictionary. local dictionary = { hello = &quot;world&quot;, goodbye = &quot;goodbye&quot; } local result = Filter(dictionary, function(value, key) return value == &quot;world&quot; end) -- { hello = &quot;world&quot; }   "},{"title":"every​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#every","content":"&lt;/&gt; Dictionary.every( dictionary: {[K]: V},-- The dictionary to check. predicate: ( value: V, key: K, dictionary: {[K]: V} ) → any-- The predicate to use to check the dictionary. ) → boolean-- Whether every item in the dictionary passes the predicate. Checks whether every item in the dictionary passes the predicate. local dictionary = { hello = &quot;world&quot;, goodbye = &quot;world&quot; } local value = Every(dictionary, function(value, key) return value == &quot;world&quot; end) -- true local value = Every(dictionary, function(value, key) return value == &quot;hello&quot; end) -- false   "},{"title":"values​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#values","content":"&lt;/&gt; Dictionary.values( dictionary: {[K]: V}-- The dictionary to get the values from. ) → {V}-- The values in the dictionary. Gets the values in the given dictionary. local dictionary = { hello = &quot;roblox&quot;, goodbye = &quot;world&quot; } local values = Values(dictionary) -- { &quot;roblox&quot;, &quot;world&quot; }   "},{"title":"copyDeep​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#copyDeep","content":"&lt;/&gt; Dictionary.copyDeep( dictionary: T-- The dictionary to copy. ) → T-- The copied dictionary. Copies a dictionary recursively. local dictionary = { hello = { world = &quot;goodbye&quot; } } local new = CopyDeep(dictionary) -- { hello = { world = &quot;goodbye&quot; } } print(new == dictionary) -- false print(new.hello == dictionary.hello) -- false   "},{"title":"fromEntries​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#fromEntries","content":"&lt;/&gt; Dictionary.fromEntries( entries: {{ K, V }}-- An array of key-value pairs. ) → {[K]: V}-- A dictionary composed of the given key-value pairs. Creates a dictionary from the given key-value pairs. local entries = { { &quot;hello&quot;, &quot;roblox&quot; }, { &quot;goodbye&quot;, &quot;world&quot; } } local dictionary = FromEntries(entries) -- { hello = &quot;roblox&quot;, goodbye = &quot;world&quot; }   "},{"title":"removeKey​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#removeKey","content":"&lt;/&gt; Dictionary.removeKey( dictionary: {[K]: V},-- The dictionary to remove the key from. key: K-- The key to remove. ) → {[K]: V}-- The dictionary without the given key. Removes the given key from the given dictionary. local dictionary = { hello = &quot;roblox&quot;, goodbye = &quot;world&quot; } local withoutHello = RemoveKey(dictionary, &quot;hello&quot;) -- { goodbye = &quot;world&quot; } local withoutGoodbye = RemoveKey(dictionary, &quot;goodbye&quot;) -- { hello = &quot;roblox&quot; }   "},{"title":"equalsDeep​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#equalsDeep","content":"&lt;/&gt; Dictionary.equalsDeep( ...: ...{[any]: any}-- The dictionaries to compare. ) → boolean-- Whether the dictionaries are equal. Compares two dictionaries for equality using deep comparison. local dictionary = { hello = &quot;world&quot;, goodbye = { world = &quot;hello&quot; } } local other1 = { hello = &quot;world&quot;, goodbye = { world = &quot;hello&quot; } } local other2 = { hello = &quot;hello&quot;, world = &quot;goodbye&quot; } local value = EqualsDeep(dictionary, other1) -- true local value = EqualsDeep(dictionary, other1, other2) -- false   "},{"title":"freeze​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#freeze","content":"&lt;/&gt; Dictionary.freeze( dictionary: T-- The dictionary to freeze. ) → T-- The frozen dictionary. Freezes the given dictionary at the top level, making it read-only. local dictionary = { hello = &quot;roblox&quot;, goodbye = { world = &quot;world&quot; } } local new = Freeze(dictionary) new.hello = &quot;world&quot; -- error! new.goodbye.world = &quot;hello&quot; -- still works!   "},{"title":"fromArrays​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#fromArrays","content":"&lt;/&gt; Dictionary.fromArrays( keys: {K},-- An array containing values to be used as keys. values: {V}-- An array containing values to be used as values. ) → {[K]: V}-- A dictionary composed of the given keys and values. Creates a dictionary from the given arrays, where the first array is used as keys and the second array is used as values. local keys = { &quot;hello&quot;, &quot;goodbye&quot; } local values = { &quot;roblox&quot;, &quot;world&quot; } local dictionary = FromArrays(keys, values) -- { hello = &quot;roblox&quot;, goodbye = &quot;world&quot; }   "},{"title":"set​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#set","content":"&lt;/&gt; Dictionary.set( dictionary: {[K]: V},-- The dictionary to set the value in. key: K,-- The key to set the value in. value: V-- The value to set. ) → {[K]: V}-- The dictionary with the given value set. Sets the given value in the given dictionary. local dictionary = { hello = &quot;world&quot;, cat = &quot;meow&quot;, unicorn = &quot;rainbow&quot; } local setCat = Set(dictionary, &quot;cat&quot;, &quot;woof&quot;) -- { hello = &quot;world&quot;, cat = &quot;woof&quot;, unicorn = &quot;rainbow&quot; }   "},{"title":"count​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#count","content":"&lt;/&gt; Dictionary.count( dictionary: T,-- The dictionary to count. predicate?: ( value: T, key: K, dictionary: T ) → any-- The predicate to use to filter the dictionary. ) → number-- The number of items in the dictionary. Counts the number of items in a dictionary. local dictionary = { hello = &quot;world&quot;, goodbye = &quot;world&quot; } local value = Count(dictionary) -- 2 local value = Count(dictionary, function(item, key) return item == &quot;world&quot; end) -- 1   "},{"title":"keys​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#keys","content":"&lt;/&gt; Dictionary.keys( dictionary: {[K]: V}-- The dictionary to get the keys of. ) → {K}-- An array containing the keys of the given dictionary. Gets the keys of the given dictionary as an array. local dictionary = { hello = &quot;roblox&quot;, goodbye = &quot;world&quot; } local keys = Keys(dictionary) -- { &quot;hello&quot;, &quot;goodbye&quot; }   "},{"title":"flip​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#flip","content":"&lt;/&gt; Dictionary.flip( dictionary: {[K]: V}-- The dictionary to flip. ) → {[V]: K}-- The flipped dictionary. Flips a dictionary. Keys become values and values become keys. local dictionary = { hello = &quot;roblox&quot;, goodbye = &quot;world&quot; } local new = Flip(dictionary) -- { world = &quot;goodbye&quot;, roblox = &quot;hello&quot; }   "},{"title":"withKeys​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#withKeys","content":"&lt;/&gt; Dictionary.withKeys( dictionary: {[K]: V},-- The dictionary to select the keys from. keys: ...K-- The keys to keep. ) → {[K]: V}-- The dictionary with only the given keys. Returns a dictionary with the given keys. local dictionary = { hello = &quot;world&quot;, cat = &quot;meow&quot;, dog = &quot;woof&quot;, unicorn = &quot;rainbow&quot; } local withoutCatDog = WithKeys(dictionary, &quot;cat&quot;, &quot;dog&quot;) -- { cat = &quot;meow&quot;, dog = &quot;woof&quot; }   "},{"title":"equals​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#equals","content":"&lt;/&gt; Dictionary.equals( ...: ...{[any]: any}-- The dictionaries to compare. ) → boolean-- Whether the dictionaries are equal. Compares two dictionaries for equality. local dictionary = { hello = &quot;world&quot;, goodbye = &quot;world&quot; } local other1 = { hello = &quot;world&quot;, goodbye = &quot;world&quot; } local other2 = { hello = &quot;hello&quot;, world = &quot;goodbye&quot; } local value = Equals(dictionary, other1) -- true local value = Equals(dictionary, other1, other2) -- false   "},{"title":"removeKeys​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#removeKeys","content":"&lt;/&gt; Dictionary.removeKeys( dictionary: {[K]: V},-- The dictionary to remove the keys from. keys: ...K-- The keys to remove. ) → {[K]: V}-- The dictionary without the given keys. Removes the given keys from the given dictionary. local dictionary = { hello = &quot;world&quot;, cat = &quot;meow&quot;, dog = &quot;woof&quot;, unicorn = &quot;rainbow&quot; } local withoutCatDog = RemoveKeys(dictionary, &quot;cat&quot;, &quot;dog&quot;) -- { hello = &quot;world&quot;, unicorn = &quot;rainbow&quot; }   "},{"title":"has​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#has","content":"&lt;/&gt; Dictionary.has( dictionary: {[K]: V},-- The dictionary to check. key: any-- The key to check for. ) → boolean-- Whether or not the dictionary has the given key. Checks whether or not the given dictionary has the given key. local dictionary = { hello = &quot;roblox&quot;, goodbye = &quot;world&quot; } local hasHello = Has(dictionary, &quot;hello&quot;) -- true local hasCat = Has(dictionary, &quot;cat&quot;) -- false   "},{"title":"entries​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#entries","content":"&lt;/&gt; Dictionary.entries( dictionary: {[K]: V}-- The dictionary to get the entries from. ) → {{ K, V }}-- The entries in the dictionary. Returns the entries in the given dictionary as an array of key-value pairs. local dictionary = { hello = &quot;roblox&quot;, goodbye = &quot;world&quot; } local entries = Entries(dictionary) -- { { &quot;hello&quot;, &quot;roblox&quot; }, { &quot;goodbye&quot;, &quot;world&quot; } }   "},{"title":"some​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#some","content":"&lt;/&gt; Dictionary.some( dictionary: {[K]: V},-- The dictionary to check. predicate: ( value: V, key: K, dictionary: {[K]: V} ) → any-- The predicate to check against. ) → boolean-- Whether or not the predicate returned true for any value. Checks whether or not the predicate returned true for any value in the dictionary. local dictionary = { hello = &quot;world&quot;, cat = &quot;meow&quot;, unicorn = &quot;rainbow&quot; } local hasMeow = Some(dictionary, function(value) return value == &quot;meow&quot; end) -- true local hasDog = Some(dictionary, function(_, key) return key == &quot;dog&quot; end) -- false   "},{"title":"freezeDeep​","type":1,"pageTitle":"Dictionary","url":"/sift/api/Dictionary#freezeDeep","content":"&lt;/&gt; Dictionary.freezeDeep( dictionary: T-- The dictionary to freeze. ) → T-- The frozen dictionary. Freezes the entire dictionary, making it read-only, including all nested dictionaries. local dictionary = { hello = &quot;roblox&quot;, goodbye = { world = &quot;world&quot; } } local new = FreezeDeep(dictionary) new.hello = &quot;world&quot; -- error! new.goodbye.world = &quot;hello&quot; -- error!  "},{"title":"Array","type":0,"sectionRef":"#","url":"/sift/api/Array","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Array","url":"/sift/api/Array#functions","content":" "},{"title":"concat​","type":1,"pageTitle":"Array","url":"/sift/api/Array#concat","content":"&lt;/&gt; Array.concat( ...: ...any-- The arrays to concatenate. ) → {T}-- The concatenated array. Joins multiple arrays together into a single array. Aliases join, merge local table1 = { 1, 2, 3 } local table2 = { 4, 5, 6 } local new = Concat(table1, table2) -- { 1, 2, 3, 4, 5, 6 }   "},{"title":"sort​","type":1,"pageTitle":"Array","url":"/sift/api/Array#sort","content":"&lt;/&gt; Array.sort( array: {T},-- The array to sort. comparator?: ( a: T, b: T ) → boolean-- The comparator function. ) → {T}-- The sorted array. Sorts an array. local array = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; } local new = Sort(array, function(a, b) return a &gt; b end) -- { &quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot; }   "},{"title":"pop​","type":1,"pageTitle":"Array","url":"/sift/api/Array#pop","content":"&lt;/&gt; Array.pop( array: {T},-- The array to pop an element from. count?: number=1-- The number of elements to pop. ) → {T}-- An array with the popped elements removed. Removes an element from the end of the array, and returns the array with the popped elements removed. local array = { 1, 2, 3 } local new = Pop(array) -- { 1, 2 } local new = Pop(array, 2) -- { 1 }   "},{"title":"copy​","type":1,"pageTitle":"Array","url":"/sift/api/Array#copy","content":"&lt;/&gt; Array.copy( array: {T}-- The array to copy. ) → {T}-- The copied array. Copies an array. local array = { 1, 2, 3 } local new = Copy(array) -- { 1, 2, 3 } print(new == array) -- false   "},{"title":"push​","type":1,"pageTitle":"Array","url":"/sift/api/Array#push","content":"&lt;/&gt; Array.push( array: {T},-- The array to push an element to. ...: ...T-- The elements to push. ) → {T}-- The array with the pushed elements. Adds elements to the end of the array. Aliases append local array = { 1, 2, 3 } local new = Push(array, 4, 5, 6) -- { 1, 2, 3, 4, 5, 6 }   "},{"title":"update​","type":1,"pageTitle":"Array","url":"/sift/api/Array#update","content":"&lt;/&gt; Array.update( array: {T},-- The array to update. index: number,-- The index to update. updater?: ( value: T, index: number ) → T,-- The updater function. callback?: (index: number) → T-- The callback function. ) → {T}-- The updated array. Updates an array at the given index. If the value at the given index does not exist, callback will be called, and its return value will be used as the value at the given index. local array = { 1, 2, 3 } local new = Update(array, 2, function(value) return value + 1 end) -- { 2, 3, 3 } local new = Update(array, 4, function(value) return value + 1 end, function(value) return 10 end) -- { 1, 2, 3, 10 }   "},{"title":"find​","type":1,"pageTitle":"Array","url":"/sift/api/Array#find","content":"&lt;/&gt; Array.find( array: {T},-- The array to search. value?: any,-- The value to search for. from?: number-- The index to start searching from. ) → number?-- The index of the first item in the array that matches the value. Finds the index of the first item in the array that matches the value. This is mostly a wrapper around table.find, with the ability to specify a negative number as the start index (to search relative to the end of the array). Aliases indexOf local array = { &quot;hello&quot;, &quot;world&quot;, &quot;hello&quot; } local index = Find(array, &quot;hello&quot;) -- 1 local index = Find(array, &quot;hello&quot;, 2) -- 3   "},{"title":"first​","type":1,"pageTitle":"Array","url":"/sift/api/Array#first","content":"&lt;/&gt; Array.first( array: {T}-- The array to get the first item from. ) → T-- The first item in the array. Gets the first item in the array. local array = { 1, 2, 3 } local value = First(array) -- 1   "},{"title":"map​","type":1,"pageTitle":"Array","url":"/sift/api/Array#map","content":"&lt;/&gt; Array.map( array: {T},-- The array to map. mapper: ( value: T, index: number, array: {T} ) → U?-- The mapper function. ) → {U}-- The mapped array. Maps the array using the mapper function. local array = { 1, 2, 3 } local new = Map(array, function(value, index) return value * 2 end) -- { 2, 4, 6 }   "},{"title":"is​","type":1,"pageTitle":"Array","url":"/sift/api/Array#is","content":"&lt;/&gt; Array.is( object: any-- The object to check. ) → boolean-- Whether the object is an array. Checks if the given object is an array. local array = { 1, 2, 3 } local dictionary = { hello = &quot;world&quot; } local mixed = { 1, 2, hello = &quot;world&quot; } Array.is(array) -- true Array.is(dictionary) -- false Array.is(mixed) -- false   "},{"title":"reverse​","type":1,"pageTitle":"Array","url":"/sift/api/Array#reverse","content":"&lt;/&gt; Array.reverse( array: {T}-- The array to reverse. ) → {T}-- The reversed array. Reverses the order of the items in an array. local array = { 1, 2, 3 } local new = Reverse(array) -- { 3, 2, 1 }   "},{"title":"zip​","type":1,"pageTitle":"Array","url":"/sift/api/Array#zip","content":"&lt;/&gt; Array.zip( ...: {any}-- The arrays to zip together. ) → {any}-- The zipped array. Zips multiple arrays together into a single array. local table1 = { 1, 2, 3 } local table2 = { &quot;hello&quot;, &quot;world&quot;, &quot;goodbye&quot; } local new = Zip(table1, table2) -- { { 1, &quot;hello&quot; }, { 2, &quot;world&quot; }, { 3, &quot;goodbye&quot; } }   "},{"title":"flatten​","type":1,"pageTitle":"Array","url":"/sift/api/Array#flatten","content":"&lt;/&gt; Array.flatten( array: {T},-- The array to flatten. depth?: number-- The depth to flatten the array to. ) → {T}-- The flattened array. Flattens an array. If depth is not specified, it will flatten the array as far as it can go. local array = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, { 8, 9 } }, } local new = Flatten(array) -- { 1, 2, 3, 4, 5, 6, 7, 8, 9 } local new = Flatten(array, 1) -- { 1, 2, 3, 4, 5, 6, 7, { 8, 9 } }   "},{"title":"includes​","type":1,"pageTitle":"Array","url":"/sift/api/Array#includes","content":"&lt;/&gt; Array.includes( array: {T},-- The array to search. value: any,-- The value to search for. from?: number-- The index to start searching from. ) → boolean-- Whether the array contains the value. Checks whether the array contains the value. This is a wrapper around Find. Aliases contains, has local array = { &quot;hello&quot;, &quot;world&quot;, &quot;goodbye&quot; } local value = Includes(array, &quot;hello&quot;) -- true local value = Includes(array, &quot;sift&quot;) -- false local value = Includes(array, &quot;hello&quot;, 2) -- false   "},{"title":"removeValues​","type":1,"pageTitle":"Array","url":"/sift/api/Array#removeValues","content":"&lt;/&gt; Array.removeValues( array: {T},-- The array to remove values from. ...: T-- The values to remove. ) → {T}-- The array with the values removed. Removes values from an array. local array = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; } local new = RemoveValues(array, &quot;c&quot;, &quot;d&quot;) -- { &quot;a&quot;, &quot;b&quot;, &quot;e&quot; }   "},{"title":"create​","type":1,"pageTitle":"Array","url":"/sift/api/Array#create","content":"&lt;/&gt; Array.create( length: number,-- The length of the array to create. value?: T-- The value to fill the array with. ) → {T}-- The created array. Creates an array of the given length, filled with the given value. This is just a wrapper around table.create. local array = Create(3, &quot;Hello&quot;) print(array) -- { &quot;Hello&quot;, &quot;Hello&quot;, &quot;Hello&quot; }   "},{"title":"splice​","type":1,"pageTitle":"Array","url":"/sift/api/Array#splice","content":"&lt;/&gt; Array.splice( array: {T},-- The array to splice. start?: number,-- The index to start splicing at (can be negative). end?: number,-- The index to end splicing at (can be negative). ...: ...T-- The values to insert. ) → {T}-- The spliced array. Splices an array. local array = { 1, 2, 3, 4, 5 } local new = Splice(array, 3, 4, 6, 7) -- { 1, 2, 6, 7, 4, 5 } local new = Splice(array, -1, 0, 6, 7) -- { 1, 2, 3, 4, 6, 7 } local new = Splice(array, 4, -1, 6, 7) -- { 1, 2, 3, 6, 7, 5 }   "},{"title":"difference​","type":1,"pageTitle":"Array","url":"/sift/api/Array#difference","content":"&lt;/&gt; Array.difference( array: Array&lt;V&gt;,-- The array to compare. ...: ...Array&lt;V&gt;-- The arrays to compare against. ) → Array&lt;V&gt;-- The difference between the arrays. Returns an array of values that are in the first array, but not in the other arrays. local array1 = { &quot;hello&quot;, &quot;world&quot; } local array2 = { &quot;cat&quot;, &quot;dog&quot;, &quot;hello&quot; } local difference = Difference(array1, array2) -- { &quot;world&quot; }   "},{"title":"last​","type":1,"pageTitle":"Array","url":"/sift/api/Array#last","content":"&lt;/&gt; Array.last( array: {T}-- The array to get the last element of. ) → T-- The last element of the array. Gets the last element of the array. local array = { 1, 2, 3 } local value = Last(array) -- 3   "},{"title":"removeIndex​","type":1,"pageTitle":"Array","url":"/sift/api/Array#removeIndex","content":"&lt;/&gt; Array.removeIndex( array: {T},-- The array to remove the value from. index: number-- The index to remove the value from (can be negative). ) → {T}-- The array with the value removed. Removes a value from an array at the given index. local array = { 1, 2, 3 } local new = RemoveIndex(array, 1) -- { 2, 3 } local new = RemoveIndex(array, -1) -- { 1, 3 }   "},{"title":"toSet​","type":1,"pageTitle":"Array","url":"/sift/api/Array#toSet","content":"&lt;/&gt; Array.toSet( array: {T}-- The array to convert to a set. ) → Set&lt;T&gt;-- The set. Converts an array to a set. local array = { &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; } local set = ToSet(array) -- { a = true, b = true, c = true, d = true }   "},{"title":"removeValue​","type":1,"pageTitle":"Array","url":"/sift/api/Array#removeValue","content":"&lt;/&gt; Array.removeValue( array: {T},-- The array to remove the value from. value: T-- The value to remove. ) → {T}-- The array with the value removed. Removes a value from an array. local array = { 1, 2, 3 } local new = RemoveValue(array, 2) -- { 1, 3 }   "},{"title":"findWhere​","type":1,"pageTitle":"Array","url":"/sift/api/Array#findWhere","content":"&lt;/&gt; Array.findWhere( array: {T},-- The array to search. predicate: ( value: T, index: number, array: {T} ) → any,-- The predicate to use to check the array. from?: number-- The index to start searching from. ) → number-- The index of the first item in the array that matches the predicate. Finds the index of the first item in the array that passes the predicate. local array = { 1, 2, 3 } local index = FindWhere(array, function(item, index) return item &gt; 1 end) -- 2   "},{"title":"reduceRight​","type":1,"pageTitle":"Array","url":"/sift/api/Array#reduceRight","content":"&lt;/&gt; Array.reduceRight( array: {T},-- The array to reduce. reducer: ( accumulator: U, value: T, index: number, array: {T} ) → U,-- The reducer to use. initialReduction?: U={T}[#{T}]-- The initial accumulator value. ) → U-- The final accumulator value. Reduces the array using the given reducer and initial accumulator value, starting from the end of the array. If no initialReduction value is given, the last item in the array is used. local array = { 1, 2, 3 } local value = ReduceRight(array, function(accumulator, item, index) return accumulator - item end) -- 0 local value = ReduceRight(array, function(accumulator, item, index) table.insert(accumulator, item) return accumulator end, {}) -- { 3, 2, 1 }   "},{"title":"at​","type":1,"pageTitle":"Array","url":"/sift/api/Array#at","content":"&lt;/&gt; Array.at( array: {T},-- The array to get the value from. index: number-- The index to get the value from (can be negative). ) → T-- The value at the given index. Gets a value from an array at the given index. local array = { 1, 2, 3 } local value = At(array, 1) -- 1 local value = At(array, 0) -- 3   "},{"title":"filter​","type":1,"pageTitle":"Array","url":"/sift/api/Array#filter","content":"&lt;/&gt; Array.filter( array: {T},-- The array to filter. filterer?: ( value: T, index: number, array: {T} ) → any-- The callback to use to filter the array. ) → {T}-- The filtered array. Filters an array using a filterer callback. Any items that do not pass the filterer will be removed from the array. If no filterer is provided, all items will be kept. local array = { 1, 2, 3 } local result = Filter(array, function(item, index) return item &gt; 1 end) -- { 2, 3 }   "},{"title":"every​","type":1,"pageTitle":"Array","url":"/sift/api/Array#every","content":"&lt;/&gt; Array.every( array: {T},-- The array to check. predicate: ( value: T, index: number, array: {T} ) → any-- The predicate to use to check the array. ) → boolean-- Whether every item in the array passes the predicate. Checks whether every item in the array passes the predicate. local array = { 1, 2, 3 } local value = Every(array, function(item, index) return item &gt; 0 end) -- true local value = Every(array, function(item, index) return item &gt; 1 end) -- false   "},{"title":"copyDeep​","type":1,"pageTitle":"Array","url":"/sift/api/Array#copyDeep","content":"&lt;/&gt; Array.copyDeep( array: {T}-- The array to copy. ) → {T}-- The copied array. Copies an array, with deep copies of all nested arrays. local array = { 1, 2, 3, { 4, 5 } } local result = CopyDeep(array) -- { 1, 2, 3, { 4, 5 } } print(result == array) -- false print(result[4] == array[4]) -- false   "},{"title":"unshift​","type":1,"pageTitle":"Array","url":"/sift/api/Array#unshift","content":"&lt;/&gt; Array.unshift( array: {T},-- The array to insert the values to. ...: ...T-- The values to insert. ) → {T}-- The array with the values inserted. Inserts values to the beginning of an array. Aliases prepend local array = { 1, 2, 3 } local new = Unshift(array, 4, 5) -- { 4, 5, 1, 2, 3 }   "},{"title":"shuffle​","type":1,"pageTitle":"Array","url":"/sift/api/Array#shuffle","content":"&lt;/&gt; Array.shuffle( array: {T}-- The array to shuffle. ) → {T}-- The shuffled array. Randomises the order of the items in an array. local array = { 1, 2, 3 } local new = Shuffle(array) -- { 2, 3, 1 }   "},{"title":"equalsDeep​","type":1,"pageTitle":"Array","url":"/sift/api/Array#equalsDeep","content":"&lt;/&gt; Array.equalsDeep( ...: ...{any}-- The arrays to compare. ) → boolean-- Whether the arrays are equal. Compares two arrays for equality using deep comparison. local array = { 1, 2, 3, { 4, 5 } } local other = { 1, 2, 3, { 4, 5 } } local value = EqualsDeep(array, other) -- true local value = EqualsDeep(array, other, { 1, 2, 3, { 4, 5 } }) -- true local value = EqualsDeep(array, other, { 1, 2, 3, { 4, 6 } }) -- false   "},{"title":"freeze​","type":1,"pageTitle":"Array","url":"/sift/api/Array#freeze","content":"&lt;/&gt; Array.freeze( array: {T}-- The array to freeze. ) → {T}-- The frozen array. Freezes the top level of the array, making it read-only. local array = { 1, 2, 3, { 4, 5, 6 } } local new = Freeze(array) new[1] = 4 -- error! new[4][1] = 7 -- still works!   "},{"title":"removeIndices​","type":1,"pageTitle":"Array","url":"/sift/api/Array#removeIndices","content":"&lt;/&gt; Array.removeIndices( array: {T},-- The array to remove the indices from. ...: ...number-- The indices to remove the values from (can be negative). ) → {T}-- The array with the values removed. Removes values from an array at the given indices. local array = { 1, 2, 3 } local new = RemoveIndices(array, 1, 2) -- { 3 } local new = RemoveIndices(array, 0, -1) -- { 1 }   "},{"title":"set​","type":1,"pageTitle":"Array","url":"/sift/api/Array#set","content":"&lt;/&gt; Array.set( array: {T},-- The array to set the value on. index: number,-- The index to set the value at (can be negative). value: T-- The value to set. ) → {T}-- The array with the value set. Sets a value on an array at the given index. local array = { 1, 2, 3 } local new = Set(array, 2, 4) -- { 1, 4, 3 } local new = Set(array, -1, 4) -- { 1, 2, 4 }   "},{"title":"count​","type":1,"pageTitle":"Array","url":"/sift/api/Array#count","content":"&lt;/&gt; Array.count( array: {T},-- The array to count the number of items in. predicate?: ( value: T, index: number, array: {T} ) → any-- The predicate to use to filter the array. ) → number-- The number of items in the array. Counts the number of items in an array. local array = { 1, 2, 3 } local value = Count(array) -- 3 local value = Count(array, function(item, index) return item == 2 end) -- 1   "},{"title":"shift​","type":1,"pageTitle":"Array","url":"/sift/api/Array#shift","content":"&lt;/&gt; Array.shift( array: {T},-- The array to shift. count?: number-- The number of items to shift. ) → {T}-- The shifted array. Removes the first item from an array and returns the array with the item removed. local array = { 1, 2, 3 } local new = Shift(array) -- { 2, 3 } local new = Shift(array, 2) -- { 3 }   "},{"title":"findWhereLast​","type":1,"pageTitle":"Array","url":"/sift/api/Array#findWhereLast","content":"&lt;/&gt; Array.findWhereLast( array: {T},-- The array to search. predicate: ( value: T, index: number, array: {T} ) → any,-- The predicate to use to check the array. from?: number-- The index to start searching from. ) → number-- The index of the last item in the array that matches the predicate. Finds the index of the last item in the array that passes the predicate. local array = { &quot;hello&quot;, &quot;world&quot;, &quot;hello&quot; } local index = FindWhereLast(array, function(item, index) return item == &quot;hello&quot; end) -- 3 local index = FindWhereLast(array, function(item, index) return item == &quot;hello&quot; end, 2) -- 1   "},{"title":"reduce​","type":1,"pageTitle":"Array","url":"/sift/api/Array#reduce","content":"&lt;/&gt; Array.reduce( array: {T},-- The array to reduce. reducer: ( accumulator: U, value: T, index: number, array: {T} ) → U,-- The reducer to use. initialReduction?: U={T}[1]-- The initial accumulator value. ) → U-- The final accumulator value. Reduces the array using the given reducer and initial accumulator value. If no initialReduction value is given, the first item in the array is used. local array = { 1, 2, 3 } local value = Reduce(array, function(accumulator, item, index) return accumulator - item end) -- -4 local value = Reduce(array, function(accumulator, item, index) table.insert(accumulator, item) return accumulator end, {}) -- { 1, 2, 3 }   "},{"title":"equals​","type":1,"pageTitle":"Array","url":"/sift/api/Array#equals","content":"&lt;/&gt; Array.equals( ...: ...{any}-- The arrays to compare. ) → boolean-- Whether the arrays are equal. Compares two arrays for equality. local array = { 1, 2, 3 } local other = { 1, 2, 3 } local value = Equals(array, other) -- true local value = Equals(array, other, { 1, 2, 3 }) -- true local value = Equals(array, other, { 1, 2, 4 }) -- false   "},{"title":"concatDeep​","type":1,"pageTitle":"Array","url":"/sift/api/Array#concatDeep","content":"&lt;/&gt; Array.concatDeep( ...: ...any-- The arrays to concatenate. ) → {T}-- The concatenated array. Joins multiple arrays together into a single array, with deep copies of all nested arrays. Aliases joinDeep, mergeDeep local table1 = { 1, 2, { 3, 4 } } local table2 = { 5, 6, { 7, 8 } } local new = ConcatDeep(table1, table2) -- { 1, 2, { 3, 4 }, 5, 6, { 7, 8 } }   "},{"title":"findLast​","type":1,"pageTitle":"Array","url":"/sift/api/Array#findLast","content":"&lt;/&gt; Array.findLast( array: {T},-- The array to search. value?: any,-- The value to search for. from?: number-- The index to start searching from. ) → number?-- The index of the last item in the array that matches the value. Finds the index of the last item in the array that matches the value. local array = { &quot;hello&quot;, &quot;world&quot;, &quot;hello&quot; } local index = FindLast(array, &quot;hello&quot;) -- 3 local index = FindLast(array, &quot;hello&quot;, 2) -- 1   "},{"title":"slice​","type":1,"pageTitle":"Array","url":"/sift/api/Array#slice","content":"&lt;/&gt; Array.slice( array: {T},-- The array to slice. from?: number,-- The index to start from (can be negative). to?: number-- The index to end at (can be negative). ) → {T}-- The sliced array. Slices an array. local array = { 1, 2, 3, 4, 5 } local new = Slice(array, 2, 3) -- { 2, 3 } local new = Slice(array, -2, -1) -- { 3, 4 } local new = Slice(array, 3) -- { 3, 4, 5 }   "},{"title":"zipAll​","type":1,"pageTitle":"Array","url":"/sift/api/Array#zipAll","content":"&lt;/&gt; Array.zipAll( ...: ...{any}-- The arrays to zip. ) → {any}-- The zipped array. Zips multiple arrays together into a single array, filling in missing values with None. local table1 = { 1, 2, 3, 4 } local table2 = { &quot;hello&quot;, &quot;world&quot;, &quot;goodbye&quot; } local new = ZipAll(table1, table2) -- { { 1, &quot;hello&quot; }, { 2, &quot;world&quot; }, { 3, &quot;goodbye&quot; }, { 4, None } }   "},{"title":"differenceSymmetric​","type":1,"pageTitle":"Array","url":"/sift/api/Array#differenceSymmetric","content":"&lt;/&gt; Array.differenceSymmetric( array: Array&lt;V&gt;,-- The array to compare. ...: ...Array&lt;V&gt;-- The arrays to compare against. ) → Array&lt;V&gt;-- The symmetric difference between the arrays. Returns an array of values that are in the first array, but not in the other arrays, and vice versa. local array1 = { &quot;hello&quot;, &quot;world&quot; } local array2 = { &quot;cat&quot;, &quot;dog&quot;, &quot;hello&quot; } local difference = DifferenceSymmetric(array1, array2) -- { &quot;world&quot;, &quot;cat&quot;, &quot;dog&quot; }   "},{"title":"some​","type":1,"pageTitle":"Array","url":"/sift/api/Array#some","content":"&lt;/&gt; Array.some( array: {T},-- The array to check. predicate: ( value: T, index: number, array: {T} ) → any-- The predicate to use to check the array. ) → boolean-- Whether some item in the array passes the predicate. Checks whether some item in the array passes the predicate. local array = { 1, 2, 3 } local value = Some(array, function(item, index) return item &gt; 1 end) -- true local value = Some(array, function(item, index) return item &gt; 3 end) -- false   "},{"title":"insert​","type":1,"pageTitle":"Array","url":"/sift/api/Array#insert","content":"&lt;/&gt; Array.insert( array: {T},-- The array to insert the value into. index: number,-- The index to insert the value at (can be negative). values: ...T-- The values to insert. ) → {T}-- The array with the value inserted. Inserts the given values into an array at the given index, shifting all values after it to the right. If the index is negative (or 0), it is counted from the end of the array. If the index to insert at is out of range, the array is not modified. local array = { 1, 2, 3 } local newArray = Insert(array, 2, 4) -- { 1, 4, 2, 3 }   "},{"title":"freezeDeep​","type":1,"pageTitle":"Array","url":"/sift/api/Array#freezeDeep","content":"&lt;/&gt; Array.freezeDeep( array: {T}-- The array to freeze. ) → {T}-- The frozen array. Freezes the entire array, making it read-only, including all nested arrays. local array = { 1, 2, 3, { 4, 5, 6 } } local new = FreezeDeep(array) new[1] = 4 -- error! new[4][1] = 7 -- error!  "}]